<!DOCTYPE html>

<head>
    <meta charset="utf-8">


    <style>
        svg {
      background-color: #f5f5f5;
    }
    .country {
      fill: transparent;
      stroke: black;
      stroke-width: 0.5px;
    }
  </style>
</head>

<body>
    <svg></svg>
    <script src="https://d3js.org/d3.v5.min.js" charset="utf-8"></script>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/tabletop.js/1.5.1/tabletop.min.js' charset="utf-8"></script>
    <script src="https://unpkg.com/topojson@3.0.2" charset="utf-8"></script>
    <script type="text/javascript">
        function init() {
            Tabletop.init({
                key: 'https://docs.google.com/spreadsheets/d/1Ibuf8phEuP4QczVYXMoTyrLycBwRECy2fYT-KOIBUGE/edit?usp=sharing',
                callback: function(data, tabletop) {
                    makeDorling(data);
                },
                simpleSheet: false
            })
        }
        window.addEventListener('DOMContentLoaded', init)

        function makeDorling(spreadsheet) {
            console.log(spreadsheet);

            let settings = spreadsheet.settings.elements[0];
            let data = spreadsheet.data.elements;

            data = data.filter(function(d) {
                return d.size;
            })

            console.log(settings);
            console.log(data);

            let width = settings.width;
            let height = settings.height;
            let svg = d3.select('svg').attr('width', settings.width).attr('height', settings.height);

            // define scale for dorling circles based on settings and data
            let radiusExtent = d3.extent(data, d => +d.size);
            let radiusScale = d3.scaleSqrt().domain(radiusExtent).range([+settings.radius_min, +settings.radius_max]);

            let nodes = [];
            let mapData;

            let simulation = d3.forceSimulation(nodes)
                .force("x", d3.forceX(function(d) {
                    return d.x;
                }))
                .force("y", d3.forceY(function(d) {
                    return d.y;
                }))
                .force("collide", d3.forceCollide(function(d) {
                    return radiusScale(d.size);
                }))
                .on("tick", ticked);

            // define projection and path-generator variables
            let projection = d3.geoNaturalEarth1(),
                path = d3.geoPath().projection(projection);

            let map = svg.append('g').classed('map', true);
            let country = map.selectAll('.country');

            let node = svg.append("g").classed('nodes', true).selectAll(".node");

            d3.json('110m.json').then(function(topoWorld) {
                // console.log(topoWorld);
                let world = topojson.feature(topoWorld, topoWorld.objects.countries);
                // console.log(world);

                projection.fitSize([width, height], world);

                // world.features.forEach(function(feature) {
                //     feature.centroid = path.centroid(feature);
                //     // console.log(feature);
                // })

                nodes = data.map(function(d){
                    // console.log(d['country']);
                    let coordinates = projection([d.lon, d.lat]);

                    d.x = coordinates[0];
                    d.y = coordinates[1];

                    return d;
                })

                // console.log(nodes);



                country = country.data(world.features);
                country.exit().remove();
                country.enter().append('path')
                    .classed('country', true)
                    .merge(country)
                    .attr('d', path);

                node = node.data(nodes);
                node.exit().remove();
                node = node.enter().append('circle')
                    .classed('node', true)
                    .attr('id', function(d) { return d.country })
                    .merge(node)
                    .attr("cx", function(d) { return d.x })
                    .attr("cy", function(d) { return d.y })
                    .attr('r', function(d){ return radiusScale(d.size)});

                simulation.nodes(nodes).alpha(1).restart();


            });

            function ticked() {
                node.attr("cx", function(d) {
                        return d.x
                    })
                    .attr("cy", function(d) {
                        return d.y
                    })
            }

        }
    </script>
</body>
